Задача 1: Задача доступа к одному ресурсу.
Задача доступа к множеству ресурсов не вполне сводится к доступу к одному ресурсу

Задача 2: производители и потребители -
храним очередь фиксированного размера, иначе если
генерирурющая способность потоков больше, чем потребляющая способность потоков
то очередь будет расти неограниченно и мы словим OutOfMemoryError

3. Задача о читателях и писателях :

Задача об обедающих философах. КРУГЛЫЙ СТОЛ
Пусть сначала философ берет правую вилку
а потом левую. К каким проблемам приведет?
К ДЭДлоку - когда все философы возьмут правую для себя вилку,
все войдут в ожидание левой вилки, но она уже взята каким-то другим, как правая


есть переменная v, которая хранит в себе значение
compareAndSet(old, new) - если ТЕКУЩЕЕ значение v равняется переданному старому значению, то
АТОМАРНЫМ образом будет записано новое значение и нам вернут true (удалось обновить значение)

Если текущее значение не равняется старому ожидаемому значению, то операция compareAndSet ничего не изменит
и вернет false

Эта операция позволяет нам производить произвольные вычисления, если  у нас не будут постоянно
прерывать параллельные потоки

ИДИОМА
do {
    old = v.get();
    new = process(old);
} while (!v.compareAndSet(old, new));


Программная транзакционная память - хотим выполнять какие-то действия независимо в разных потоках,
а потом объединять результаты
