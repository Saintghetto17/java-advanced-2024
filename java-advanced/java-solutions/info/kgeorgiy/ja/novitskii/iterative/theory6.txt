Механизмы организации взаимодействия взаимодествия потоков внутри программы -
Синхронизация (блокировки), обмен сообщениями

Итеративный параллелизм:
Можно разные итерации цикла разнести на разные вычислительные ядра, например
c[i][j] вычислять для разных i, j на разных потоках

Обмен сообщениями:


Рекурсивный параллелизм:
если два вызова функции не зависят друг от друга, то их можно распараллелить

<Неделимая операция> - это какой то набор действий, который с точки зрения всех других потоков,
либо еще не начал исполняться, либо уже был исполнен  весь целиком

<Неделимая операция с ожиданием условия> - ждет пока исполнения условия, а когда условие вып
, она неделимым образом исполняет действия, прописанные в ней. (НЕТ НИКАКОГО ПРОМЕЖУТОЧНОГО СОСТОЯНИЯ)

ОБЫЧНО ВЫТЕСНЯЮЩИЙ
Свойства планировщика :
1) Кооперативная многозадачность (поток решает, что ему не нужны более вычислительные ресурсы)
2) Вытесняющая многозадачность (Могут отобрать процессор в любой момент времени,
 закончена неделимая операция, возможно нас вытеснят, нужно аккуратно выделять неделимые операции)

3) Безопасность - выполняет набор установленных правил
4) Живучесть - есть хотя бы 1 живой поток, то он будет исполняться
5) Справедливость - гарантии при распределении ресурсов. а)Безусловная справедливость
(отсутствие условно неделимых операций), каждый поток получит вычислительные ресуры для исполнения.
б) Слабая - условие при котором будет выделен ресурс ОБЯЗАНО БЫТЬ ВСЕГДА ИСТИННЫМ
в) Сильная - условие было истино, потом может стать ложным. При этом было истинно бесконечно много раз


Если поток никак не взаимодействует с другими потоками то его жизненный цикл таков:
New(создание) -> Runnable (Ready | Running) -> Terminated (return | throw)

Если взаимодействует :
они могут это делать через блокировки(Blocked) -> поток переходит в состояние
Runnable только после получения блокировки (BLOCKED - хочет взаимодействия с
ресурсами, ждет пока это освободят)
Waiting -> дождался и переходит в Runnable (ждет ЧЬЕГО-ТО результата)

Приоритет потока КАК ТО учитывается планировщиком
Свойства потока , когда он уже запущен менять нельзя

Ожидание завершения потока - .join(time?) (time время ожидания второго потока)
Метод join() позволяет приостановить выполнение текущего потока до тех пор, пока
поток, к которому применен данный метод, не закончит работу.
Thread t1 = new Thread(() -> {/* Здесь может быть ваш код */});
t1.start();
t1.join();  // Ожидаем завершения потока t1
// Основные действия начнут выполняться после завершения потока t1!
А еще можно ожидать какое то количество времени

// Создаём поток
        // Допустим, поток выполняет какие-то сложные вычисления
        MyThread thread = new MyThread();
        // Запускаем поток
        thread.start();

        // Прежде, чем выводить результаты вычислений
        // нужно дождаться окончания выполнения потока thread
        // Метод join() приостановит выполнение потока main до тех пор,
        // пока поток thread не завершит работу

        try {
            thread.join();
        } catch (InterruptedException e) {
            System.out.println("Поток был прерван");
        }

thread.interrupt() -> попросить прервать исполнение потока
Ожидающие методы должны бросать Interrupted exception

daemon - демон поток.

JVM ждет окончания исполнения всех потоков, у которых не стоит флаг "daemon"
Если поток демон , то JVM, может не дожидаться окончания его исполнения

Для обычного потока известно, что будет исполнен тот код, который написан
для обычного потока известно, что то, что написано в потоке будет исполняться
в написанном порядке. Для демонического потока - это неправда.

Thread.sleep(time) -> дать поспать потоку, он запустится не ранее чем через time


Thread.yield() -> кооперативная многозадачность, вот сейчас прервать поток, но он ничего не гарантирует

Thread.interrupted() проверяет - прерван ли поток, если да, то флаг прерывания снимается
Если вылетело исключение InterruptedException e, то потое прерван.
Наружу желательно сообщить, что поток прервали. Thread.currentThread().interrupt() - ставим флаг


IllegalArgumentException нужно бросать, когда аргумент не тот, какой должен быть
