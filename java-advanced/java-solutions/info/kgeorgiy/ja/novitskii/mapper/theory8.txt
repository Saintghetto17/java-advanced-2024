В Java для синхронизации используются блокировки
Синхронизация делает объект доступным изнутри одного потока, а
для внешних потоков доступ к этому объекту заблокирован


В любой момент времени блокировкой может владеть не более 1 потока
lock - получить блокировку
unlock - отдать блокировку

Runnable в состоянии продолжения работы
Если блокировка свободна, то поток ее возьмет и продолжит исполнение - Runnable

Но что, если блокировкой владеет другой поток?
Поток перейдет в состояние Blocked - в ожидание, пока не получит блокировку

Любой объект может служить блокировкой в Java
Снятие блокировки автоматически

Синтаксис:

syncronized(o) { Получение блокировки по объекту o

} Снятие блокировки

С каждым объектом ассоциирована блокировка

Два потока могут одновременно владеть блокировками на разные объекты
Поток может владеть несколькими блокировками (вложенные)

Метод экземпляра может быть объявлен синхронизованным

public syncronized int getValue(){} ~
public int getValue() {
    synchronized(this) {...}
}
____
То есть на одном объекте не может быть вызвано более одного
синхронизированного метода параллельно, так как this залочен
____

Метод класса также может быть объявлен синхронизованным:

public static synchronized int getValue() {} ~

синхронизация по type токену:

class Example {
    public static synchronized int getValue(){}
}

class Example {
    public static int getValue() {
        synchronized(Example.class) {...}
    }
}

___
Аналогично за раз может не более одного синхронизированного статического метода выполняться
___


При этом !!! Параллельно синхронизированный статический метод и
синхронизированный метод экземпляра могут выполняться параллельно

Блокировки в Java реинтерабельны, ими можно владеть несколько раз


Производитель-потребитель

Нет гарантии на то, что если производители постоянно что-то пишут,
что каждый конкретный производитель передаст свои данные потребителю

Активное ожидание - это BadPractice - ТАК НЕ НАДО! while (true) : cond

Как избавиться от активного ожидания?


Помимо того, что с каждым объектом может быть связана блокировка,
ЛЮБОЙ ОБЪЕКТ МОЖЕТ БЫТЬ МОНИТОРОМ

ЭТО ЗНАЧИТ, ЧТО ЧЕРЕЗ ОБЪЕКТ МОЖНО ПЕРЕДАВАТЬ СОБЫТИЕ!
Информацию о наступлении

- Ожидание условия wait(time?)
- Извещение одного из ждущих потоков
- Извещение всех ждущих потоков

(Поток снимает блокировку)
wait(time) - освобождает объект монитор ,который захвачен synchronized
,останавливает выполнение метода.

(При извещении поток не получает управления, пока не может получить блокировку обратно)
notify() - продолжает работу потока, у которого ранее был вызван метод wait(),
возвращая ему монитор (КАКОЙ ТО ИЗ ПОТОКОВ ПРОДОЛЖИТ)

notifyAll() - продолжает работу всех ждущих данный монитор

Для того, чтоб вызвать wait и notify нужно владеть блокировкой


Так как потребителей много, производителей много и
одновременно может работать потребитель и ждать какой то,
мы должны вызывать notifyAll, чтоб извещались все ждущие, а не какой то рандомный
, чтоб внезапно не произошло цикла ожидания.



ПРАВИЛО - ЕСЛИ ВСЕ ЖДУТ ОДНОГО И ТОГО ЖЕ СОБЫТИЯ, например если были бы
все потребители можно использовать notify()

ЕСЛИ ЕСТЬ ПОТОКИ РАЗНЫХ ТИПОВ - потребители и производители - notifyAll()

while - если хотели разбудить поток другого типа

while нужно писать, потому что могут быть внезапные пробуждения -
если мы внезапно пробудимся, то с if-ом мы сразу выйдем, а c while-ом
все еще будет крутиться в цикле, вызывая wait(), пока не вызовется notify()\


Монитор - разделяемые переменные кинапсулированы в мониторе
Код в мониторе исполняется не более чем одним потоком
Java объект можно сделать

Между операциями блокировка опускается, то есть мы вызвали один
synchronized метод, он отработал с блокировкой, мы вызвали другой
synchronized метод, он отработал с блокировкой, внутри каждого метода все
хорошо. НО что произошло между вызовами этих методов -
пусть мы синхронизованно проверили, что очередь !пуста, потом синхронизованно
попробовали достать из нее, НО МОЖЕМ ПОЛУЧИТЬ ОШИБКУ, так как между ними очередь могла опустошиться


ЧТОБ ВСЕ РАБОТАЛО обернем в synchronized, но это сильно усложняет работу

В однопоточном режиме тормозят, а в многопоточном все равно используют синхронизацию


Модель памяти Java :
- Что может увидеть операция чтения?
Для однопоточной : результат последней записи в данную переменную
Для многопоточной : что такое последняя запись?

Для многопоточных программ существует совсем иная модель памяти
Гарантии:
1) Атомарность - операция выполняется, как единое целое, то есть
является неделимой операцией с точки зрения других потоков
Чтение и присвоение(запись) значений являются атомарными, кроме long и double

2) Видимость. Какие действия считаются видимыми в программе?
ВЛАДЕНИЕ БЛОКИРОВКОЙ
ДЛЯ КАЖДОЙ КОНКРЕТНОЙ БЛОКИРОВКИ СЕРИАЛИЗУЕМО - у нас есть последовательность
интервалов времени, когда какой-то поток владеет блокировкой, они
не пересекаются, и они упорядочены

JAVA гарантирует, что все изменения, которые были произведены в 1 потоке
ДО момента, когда он отпустил блокировку, будут видны всему коду во 2 потоке,
начиная с того момента, когда он получил блокировку

Серилизуемость - существование последовательной согласованности, последовательное
исполнение действий


Порядок действий - внутри потока действия выполняются последовательно
С точки зрения других потоков - выполнение может
производиться в произвольном порядке

Volatile-переменные - можно объявить поля с volatile модификатором
многопоточной локальной перемеменной де-факто нет (нельзя обратиться к локальной переменной в другом потоке)

volatile - все операции с volatile переменными атомарны

При чтении значения volatile-переменной оно всегда читается из общей памяти
При записи значения volatile-переменной оно всегда записывается в общую память

Пусть list не volatile
Глобально мы увидели изменения глобальной переменной list, но вообще
нам никто не гарантирует, что мы увидим изменение той области памяти,
на которую действует ссылка list. Понятно, что там что-то лежит, НО
l.add("Hello")  увеличивает size на 1, но никто не гарантирует, что
мы увидим эти изменения глобально, ведь ссылка на локальную область
, где лежит size, а значит глобально мы можем не увидеть, что size
поменялся

Либо мы случайно увидим , что size+=1, но не увидим, что в него
что-то положили

НАМ НИКТО НЕ ГАРАНТИРУЕТ ВИДИМОСТЬ КАКИХ-ТО изменений

С volatile будет запись в общую память и все будет видно

ЕСТЬ ГАРАНТИЯ ВИДИМОСТИ ИЗМЕНЕНИЙ ГЛОБАЛЬНО
Volatile гарантирует, что получение ссылки и чтение переменной идет
после записи в эту переменную , запись идет в общую память, а не локальную


deadlock - взаимная блокировка
obj1
obj2

obj1 вызывает синхр метод , ставит на себя блокировку
obj2 вызывает синхр метод, ставит на себя блокировку

внутри метода obj1 вызывается метод по obj2, но obj2 залочен - ожидание разлока obj2
внутри метода obj2 вызывается метод по obj1, но obj1 залочен - ожидание разлока obj1

Не изменяются с момента создания :
1) все поля final, ссылаются только на неизменяемые объекты
- потокобезопасны, не нужна синхронизация


Эффективно неизменяемые : не изменяются с определенного момента

