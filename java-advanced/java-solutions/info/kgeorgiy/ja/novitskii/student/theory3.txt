Функциональный интерфейс - это любой интерфейс,
который содержит ровно 1 метод без реализации по умолчанию.

1. void Runnable.run() -> абстрактное действие
2. T Supplier<T>.get() -> получить объект
3. void Consumer<T>.accept(t) - действие над значением, потребление объекта
4. R Function<T, R>.apply(t)
5. void Log.log(message)
Желательно помечать аннотацией функциональный интерфейс
@FunctionalInterface

Лямбда выражение по определению - это способ
реализации функционального интерфейса
Мы банально переопределяем метод функционального интерфейса.

orElse *** ИСПОЛЬЗУЙ orElse ДЛЯ МАТЬ ЕГО БЕЗОПАСНОЙ РАБОТЫ С Optional
orElse используем, когда не знаем, Пустой opr или непустой,
чтоб не выскочило ошибок
opr.orElse("") если opt.ifPresent = TRUE, то вернет то, что в Optional, если false, то ""


Comparator.naturalOrder() -> вернет компаратор в порядке возрастания
comp.reversed() -> вызывать на компараторе, вернет компаратор, сравнивающий в порядке убывания
Comparator.comparing(Function<T, E>) -> конструирует компаратор, сравнивающий по функции, передать
компаратор в comparing нельзя
comp.thenComparing(Comparator<T>) -> последующее сравнение по переданному компаратору. Принимает компаратор, или лямбду.


ЛЕКСИКОГРАФИЧЕСКОЕ ПОСЛЕДОВАТЕЛЬНОЕ СРАВНЕНИЕ ПО НЕСКОЛЬКИМ КОМПАРАТОРАМ
УДОБСТВО this.thenComparing. Если мы хотим из this компаратора, сделать скомпозированный компаратор,
который работает по принципу : сначала сравни элементы по одному компаратору, а затем в случае равенства
по другому компаратору, ТО НАДО ИСПОЛЬЗОВАТЬ thenComparing!!!


Обратный ПОРЯДОК:
Хотим использовать компаратор, который сортирует/сравнивает в обратном порядке. ИСПОЛЬЗУЙ comp.reversed()
Comparator.comparing(Student::weight).reversed()
Comparator.comparing(UniqueClass::getValue).thenComparing(Comparator.comparing(UniqueClass::getKey).reversed())


ПРАВИЛО -> для получения каких-то конкретных значений из потока ИСПОЛЬЗУЙ промежуточные операции КАК МОЖНО ДОЛЬШЕ,
доходя до наиболее простых объектных конструкций. Почему? Потому что промежуточные операции возвращают Optional
, а нам все таки хочется обрабатывать Optional для более понятных значений, используя orElse для возврата по умолчанию